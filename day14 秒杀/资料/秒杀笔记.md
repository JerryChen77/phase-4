

# 一、电商项目搭建

## 1.搭建后台

- 修改后台项目中的数据库的连接信息：db.properties
- 修改后台项目中的redis的连接信息:application-context-redis.xml

- 部署在本地的tomcat服务器上，注意路径：

<img src="img/截屏2021-08-25 下午3.00.40.png" alt="截屏2021-08-25 下午3.00.40" style="zoom:33%;" />

<img src="img/截屏2021-08-25 下午3.00.56.png" alt="截屏2021-08-25 下午3.00.56" style="zoom:33%;" />





## 2.搭建前台：

- cnpm install
- npm run dev

# 二、秒杀的背景

## 1.为什么要学习秒杀

因为秒杀的项目会让大家体会到真正的高并发、高性能、高可用的系统架构设计（工程架构、中间件架构、业务架构）。

日常高并发出现场景：

- 12306抢火车票
- 支付宝抢杭州优惠卷
- 浙江医疗预约挂号
- 抢耐克 抢茅台

秒杀的项目，无论是在电商、医疗、金融、教育、政府项目等等这些场景下，都会出现。秒杀的项目是最考验一个程序的系统设计能力的：并发编程、系统技术选型、架构应用的能力。

## 2.秒杀项目目前的地位

凡是要涉及到互联网营销，秒杀绝对是一个非常棒的突破口。从京东首页的秒杀模块就能看出秒杀项目的重要性。



## 3.秒杀项目要实现目录

通过优秀的架构设计，让系统能够顺利扛下大并发！我们自己也能形成一个应对大并发的解决方案的指导思想。

# 三、秒杀的中间件架构

![截屏2021-08-25 下午3.44.58](img/截屏2021-08-25 下午3.44.58.png)

上面的中间件架构图其实是适用于很多微服务的场景，但是并不能体现技术的深度。整个系统的性能关键，除了使用这些中间件以外，还有在业务层面进行详细的设计。



# 四、秒杀系统的前端架构

## 1.为什么要聊前端

秒杀接口被访问的前提是商品详情页顺利打开之后。那么如何保证商品详情页能顺利打开？这就跟前端架构有关系。

## 2.前端架构

前端使用相应的技术，让用户直接访问静态页面，而是通过用户的访问java程序动态生成页面。

- 当系统管理员在后台管理系统中添加秒杀商品后，生成静态页面-手淘就提出-首页秒开

![截屏2021-08-25 下午4.05.52](img/截屏2021-08-25 下午4.05.52.png)

- 并且把静态资源上传到支持cdn的分布式文件存储系统中

![截屏2021-08-25 下午4.07.04](img/截屏2021-08-25 下午4.07.04.png)



# 五、秒杀系统的后端数据流转

![截屏2021-08-25 下午4.16.10](img/截屏2021-08-25 下午4.16.10.png)



# 六、超卖问题

## 1.秒杀系统的基本优化思路

通过设置多个门槛。让真正有效的请求才会去执行创建订单的动作，无效的请求会直接被return拒绝。

![截屏2021-08-25 下午4.20.39](img/截屏2021-08-25 下午4.20.39.png)



## 2.提交订单之前的库存判断，这个库存放哪里？

库存直接决定了交易是否成功，那么每次访问秒杀接口，实际上都要去判断是否还有库存？那库存放哪里？放到redis缓存服务器中。

MySQL表里是有该商品的真实库存的。





## 3.什么叫超卖？

卖出的商品数量超过了库存数量。为什么会出现超卖？

![截屏2021-08-25 下午4.32.30](img/截屏2021-08-25 下午4.32.30.png)

如果没有使用redis的原子操作，那么就极容易出现超卖问题。

## 4.如何解决超卖？

如果上锁的话，一旦用了锁，就会消耗性能。可以使用redis的单线程特性，结合redis原子操作来实现上锁的效果。让并行转为串行。

![截屏2021-08-25 下午4.43.02](img/截屏2021-08-25 下午4.43.02.png)



# 七、少卖问题

## 1.少卖出现的场景

如果有之前成功扣减redis库存的线程，在提交订单的时候失败了，那么就需要将redis中的库存+1，但此时redis的库存已被多个并发的线程扣减成了负数，于是+1完以后还是<=0的值，也就意味着库存依然没有，刚才+1的商品始终卖不出去，于是就少卖了。



## 2.解决方案

让把redis库存扣减成负数的线程 去执行+1的动作，让redis的库存始终保持是一个=0的状态。

![截屏2021-08-26 上午9.34.47](img/截屏2021-08-26 上午9.34.47.png)



面试官经常会问：你的系统中redis和mysql的数据是怎么同步的？

- 对于秒杀系统来说，这个方案就是当提交订单时，去mysql的库存库里扣减，实现redis和mysql的数据同步
- 对于其他系统来说，具体的方案在后面专题去讲



# 八、如何解决秒杀已结束但依然要去扣减redis库存的问题

## 1.已结束后的redis的扣减会影响性能

redis中的库存已被扣完，但依然有很多用户的请求继续访问后端接口，如果这样的请求非常多，会造成后端多余的开销

## 2.解决方案：在redis里设置一个秒杀结束标记(不建议)

当redis的库存扣完，那么就向redis存放一个结束标记，在下一次请求的时候，判断是否有结束标记。如果有就直接返回，不执行后面的额扣减。但是这种方案性能不好。

![截屏2021-08-26 上午9.51.45](img/截屏2021-08-26 上午9.51.45.png)

## 3.该方案存在的弊端

虽然设置的标记，但是redis的io请求次数没有减少，反而在正常扣减之前增加了redis的io次数。



## 4.另一套方案：使用jvm本地缓存来存放结束标记(推荐)

使用一个存放在jvm本地内存中的数据结构-ConcurrentHashMap来存放结束标记，减少redis的io

![截屏2021-08-26 上午10.08.59](img/截屏2021-08-26 上午10.08.59.png)

结束标记放在本地，每次执行业务之前先查看本地是否有结束标记，如果有则不执行之后的业务。

![截屏2021-08-26 上午10.09.35](img/截屏2021-08-26 上午10.09.35.png)

# 九、ConcurrentHashMap的特点

## 1.为什么要使用HashMap

因为HashMap的查询性能非常快，查询的时间复杂度是O(1)

- 数组：查询快（根据索引来查询）O(1)，没有索引就是O(n)，增删慢
- 链表：查询慢，要逐一遍历，O(n);增删快
- HashMap：查询快，增删也是很快的



## 2.HashMap的put过程

- 根据entry的key做hash运算，决定存放在哪个哈希表的位置中
- hash碰撞时元素增加：JDK1.7使用了头插法、JDK1.8使用了尾插法。

hashmap默认的负载因子是0.75，默认的初始化容量是16。当hashmap中的元素个数超过16X0.75的时候，就会进行扩容。

1.7是先扩容，再插入，会造成死循环

<img src="img/截屏2021-08-26 上午11.12.09.png" alt="截屏2021-08-26 上午11.12.09" style="zoom:50%;" />

1.8是先插入，再扩容，不会造成死循环

- JDK1.8加入了红黑树（能够自己维护平衡的一种特殊的平衡排序树）：如果说在hashmap中一个链表的长度大于等于8，那么这个链表会被转换成红黑树，目的是提升查询的性能。

为什么链表的长度大于等于8时会转换成红黑树：因为根据离散特性，8转换成红黑树对于系统的整个性能是最好的。

- 如果这个红黑树上的元素个数小于等于6，那么红黑树会转换回链表

为什么小于等于6，而不是直接小于等于8，一下等于7，一下等于8，给了一个缓冲的区间。

![截屏2021-08-26 上午11.00.02](img/截屏2021-08-26 上午11.00.02.png)



## 3.线程安全的HashMap

系统一旦涉及到线程安全问题，我们考虑的出发点就是：如何既保留了性能又保障了安全。

HashMap本身是线程不安全的，如何解决线程安全问题：

- Hashtable:对读的操作都上锁，并发性非常差

- ConcurrentHashMap：1.8版本的性能几乎与线程不安全的HashMap相同了。

  - 1.7 :使用segment上分段锁:锁的粒度变小，但是粒度还不够小
  - ![截屏2021-08-26 上午11.32.56](img/截屏2021-08-26 上午11.32.56.png)
  - 1.8：使用cas+synchronized上锁（锁的粒度更小、synchronized会进行膨胀升级）

## 4.CAS机制

### 1）乐观锁和悲观锁

  - 悲观锁：总有刁民要害朕。 悲观的认为当前系统的并发性非常严重。所以任何的操作都要上锁。
  - 乐观锁：天网恢恢疏而不漏。乐观的认为当前系统的并发性不严重，所以基本上不上锁，但真的产生并发的时候，会有相关的机制来保证安全

### 2）CAS怎么实现

  CAS是一种乐观锁，当出现并发的时候，通过自旋来保证数据安全。CAS需要获得三个值

  - 内存地址v
  - 旧的期望值A
  - 新值B

  使用cas来修改数据，需要进行以下流程

  - 先获得内存地址V中的旧值A
  - 然后算出新值B。在提交的时候去查看内存地址V中的实际值是否和A相同，如果相同，提交成功；如果不相同， 自旋，更新旧值A，再次提交。

  CAS来说适用于并发不严重的情况，如果并发严重，那么自旋的情况会频繁出现，导致系统造成额外的较大的开销。

### 3）CAS中的ABA问题

当线程在提交的时候，因为阻塞导致提交的内部被多次更改，而此时旧值和多次更改的值是相同的（A->B->A），于是也提交成功了，实际上被多次修改了，那么这一次提交不应该成功，应该报错。此时可以通过版本号来解决这个问题。



#  十、将秒杀接口冗余部署到多个JVM后秒杀标记会造成不公平的情况

## 1.不公平情况的出现

当jvm冗余部署多台，如果之前有的线程在秒到最后一个商品发生了退库的操作，在这过程中，多个线程已经把结束标记打在了每个jvm本地，那么此时退库操作会把结束标记删掉，但只能删除该线程所访问的jvm的本地的标记。这就意味着，如果接下来再有请求访问的是这台jvm可以继续秒杀，但访问其他jvm，结束标记还在，不能秒杀。这就是不公平情况。

![截屏2021-08-26 下午2.32.42](img/截屏2021-08-26 下午2.32.42.png)



## 2.解决不公平问题

使用zk的watch机制

- 在线程扣减完redis库存发现库存不足时，创建结束标记
- 在zk中创建节点，并监听
- 设置回调方法，回调方法的内容根据 zk中节点的内容，是否删除结束标记
- 当有线程发生退库操作，修改zk中节点的内容
- 之前监听zk该节点的所有客户端的回调方法被调用，删除本地的结束标记

![截屏2021-08-26 下午2.47.25](img/截屏2021-08-26 下午2.47.25.png)



# 十一、防止同一个用户重复下单

## 1.问题的出现

当一个用户在抢购商品的时候，会疯狂点前端的按钮，很容易后端就会收到同一个用户的多个请求。如果不做限制，就有可能，这一次用户的重复点，该用户的多个请求会创建出多个订单。

## 2.解决方案

当用户创建订单成功后，在redis里放一个下单成功的标记。之后的请求去判断当前该用户的下单成功的标记是否已存在，如果已存在则直接返回

![截屏2021-08-26 下午3.02.23](img/截屏2021-08-26 下午3.02.23.png)

## 3.存在的问题

当用户并发访问的时候，线程1还没来的及存放标记，线程2就进来了继续提交订单，这样依然会出现重复购买的问题。



# 十二、前端如何有效获取秒杀结果

## 1.前端如何获得秒杀结果



![截屏2021-08-26 下午3.11.01](img/截屏2021-08-26 下午3.11.01.png)



## 2.前端设置定时器，定时访问后端接口

![截屏2021-08-26 下午4.05.07](img/截屏2021-08-26 下午4.05.07.png)



## 3.后端提供返回秒杀结果的接口

使用分布式锁实现排队标记，也解决了上一点中出现的问题

这里的设置排队的方式也可以换成设置if(redisUtil.incre(key)>1)，如果为true则return “当前正在排队”

![截屏2021-08-26 下午4.03.35](img/截屏2021-08-26 下午4.03.35.png)



# 十三、如何保证接口安全

## 1.什么是接口安全

在早期的抢票环节，经常可以使用一些工具来盗刷接口，所以很多平台就出了一些具体的方案：

## 2.解决接口安全问题的方案

- 验证码：验证码的目的是为了排除机器在盗刷，判断当前是否是人类的操作。道高一尺魔高一丈

  之后的支付宝有个风控部门，因为访问频繁等等原因，你的风控系数上去了，于是支付宝给的验证码会非常非常难：1822199231/1293123=？

- 前端隐藏接口：前端vue框架基本上都是可以隐藏接口：http拦截工具是可以查看到访问的接口

- 使用一次性token做有效性验证。



## 3.对于只用验证码的情况来说会出现的问题

![截屏2021-08-26 下午4.17.52](img/截屏2021-08-26 下午4.17.52.png)

虽然验证码能拦截一部分机器，和分流。但是黑客依然有办法去使用人肉平台获得非常难的验证码去盗刷接口，那如何解决这个问题？

使用一次性token做安全校验。防止接口被频繁盗刷，导致服务器压力过大。

![截屏2021-08-26 下午4.32.43](img/截屏2021-08-26 下午4.32.43.png)



# 作业

- 掌握什么是少卖及如何解决
- 掌握如何对秒杀系统做性能优化：把结束标记放到本地缓存的ConcurrentHashMap中
- 掌握HashMap、ConcurrentHashMap的细节及面试题
- 掌握如何对秒杀系统做性能优化：如何防止同一用户重复下单
- 掌握如何保证秒杀接口安全：验证码+一次性token校验逻辑掌握情况
- 看看代码，简历。